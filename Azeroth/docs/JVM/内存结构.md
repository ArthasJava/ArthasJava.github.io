---
title: 内存结构
date: 2021-04-01
sidebar: 'auto'
---


## 运行时数据区
JVM 运行时数据区包括：
1. 线程安全：程序计数器、虚拟机栈、本地方法栈
2. 线程不安全：方法区、堆

![运行时数据区](https://tva1.sinaimg.cn/large/0082zybply1gc6fz21n8kj30u00wpn5v.jpg) 

## 程序计数器
::: theorem
程序计数器是一块较小的内存空间，可以看做是当前线程所执行的字节码的**行号指示器**。
::: right
来自 [ 深入理解 Java 虚拟机]
:::

Java 虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器都只会执行一条线程中的指令。因此，为了线程切换能恢复到正确的执行位置，每个线程都需要一个独立的程序计数器。我们称这类内存区域为**线程私有**的内存。

如果线程正在执行的是一个 Java 方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；
如果线程正在执行的是一个 Native 方法，这个计数器值则为空。

::: tip
- 程序计数器是唯一一个在 Java 虚拟机规范中没有规定任何 `OutOfMemoryError` 情况的区域
- 运行速度最快的存储区域
- 线程私有的，生命周期与线程的生命周期一致
- 字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令
:::

## 虚拟机栈
- 线程私有，每个线程在创建的时候都会创建一个虚拟机栈，内部保存一个个的栈帧，生命周期与线程相同
- 栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器
- 可以通过参数-Xss来设置线程的最大栈空间，栈的大小直接决定了函数调用的最大可达深度

::: tip
虚拟机栈描述的是 Java 方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。

每个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出站的过程。
:::

::: theorem
虚拟机栈存在两种异常状况：
- 如果现场请求的栈深度大于虚拟机所允许的深度，将抛出 `StackOverflowError`异常
- 如果虚拟机栈可以动态扩展，如果扩展时无法申请到足够的内存，就会抛出`OutOfMemoryError`异常
::: right
来自[ Java 虚拟机规范 ]
:::

### 栈帧的内部结构
每个栈帧中存储：
- 局部变量表
- 操作数栈
- 动态链接：指向运行时常量池的方法引用
- 方法返回地址：方法正常退出或者异常退出的地址
- 附加信息

![栈帧结构](https://tva1.sinaimg.cn/large/0082zybply1gc8tjehg8bj318m0lbtbu.jpg)

**局部变量表**
- 存放了编译期可知的各种基本数据类型、对象引用和 returnAddress 类型（指向了一条字节码指令的地址）

槽 Slot：
- 局部变量表最基本的存储单元是 Slot （变量槽）



> 64 位长度的 long 和 double 类型的数据会占用 2 个局部变量空间（Slot），其余的数据类型只占用 1 个。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。

