---
title: 类加载机制
date: 2021-04-11
sidebar: 'auto'
---

::: tip
本文大部分内容来自 [JVM解毒——类加载子系统](https://juejin.cn/post/6844904069702615054)
:::

## 类加载子系统
![类加载子系统图](https://tva1.sinaimg.cn/large/0082zybply1gbzlnjzayoj30u00wpwn7.jpg)

**Java 虚拟机把描述类的数据从 Class 文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的 Java 类型，这就是虚拟机的加载机制。**

Class 文件由类装载器装载后，在 JVM 中将形成一份描述 Class 结构的元信息对象，通过该元信息对象可以获知 Class 的结构信息：如构造函数，属性和方法等，Java 允许用户借由这个 Class 相关的元信息对象间接调用 Class 对象的功能，这里就是我们经常能见到的 Class 类。

## 类加载子系统作用
- 类加载子系统负责从文件系统或者网络中加载 class 文件，class 文件在文件开头有特定的文件标识 （**0xCAFEBABE**）
- ClassLoader 只负责 class 文件的加载。至于它是否可以运行，则由 **Execution Engine** 决定
- 加载的类信息存放于一块称为**方法区**的内存空间。除了类的信息外，方法区中还存放运行时常量池信息，可能还包括字符串字面量和数字常量（这部分常量信息是class文件中常量池部分的内存映射）
- Class 对象是存放在**堆区**的

## 类加载器 ClassLoader 角色
1. class file 存在于本地硬盘上，可以理解为设计师画在纸上的模板，而最终这个模板在执行的时候是要加载到JVM 当中来根据这个文件实例化出 n 个一模一样的实例
2. class file 加载到 JVM 中，被称为 DNA 元数据模板，放在方法区
3. 在 .class 文件 -> JVM -> 最终成为元数据模板，此过程就要一个运输工具（类装载器），扮演一个快递员的角色

## 类的生命周期

类加载的过程包括：
- 加载
- 验证
- 准备
- 解析
- 初始化

::: danger
除了解析，其他四个阶段发生的顺序都是确定的

解析在某些阶段可以在**初始化**阶段之前，这是为了支持 Java 语言的运行时绑定
:::

### 类的加载
::: tip
查找并加载类的二进制数据
:::

加载阶段，虚拟机需要完成以下三件事情：
1. 通过类的**全限定名**来获取其定义的二进制字节流
2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
3. Java 堆中生成一个代表这个类的 `java.lang.Class` 对象，作为对方法区这些数据的访问入口

加载阶段是相对于其他阶段是可控性最强的阶段，因为开发者可以使用系统提供的类加载器来完成加载，也可以自定义自己的类加载器来完成加载。

加载阶段完成或，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区中，而在Java堆中创建一个 `java.lang.Class`对象，这样可以通过该对象访问方法区中的数据

::: warning
类加载器并不需要等到某个类被“首次主动使用”时再加载它，JVM 规范允许类加载器在预料某个类将要被使用时就预先加载它，如果在预先加载的过程中遇到了`.class`文件缺失或存在错误，类加载器必须在程序首次主动使用该类时才报告错误，如果这个类一直没有被程序主动使用，那么类加载器就不会报告错误
:::

加载`.class`文件的方式：
- 从本地系统中直接加载
- 网络下载`.class`文件
- 从 zip, jar 等归档文件中加载`.class`文件
- 从专有数据库中提取
- 将 java 源文件动态编译为`.class`文件

### 验证
::: tip
确保被加载的类的正确性
:::

## 面试常问
1. 看你简历写得熟悉 JVM，那你说说类的加载过程吧？
2. 我们可以自定义一个 String 类来使用吗？
3. 什么是类加载器，类加载器有哪些？这些类加载器都加载哪些文件？
4. 多线程的情况下，类的加载为什么不会出现重复加载的情况？
5. 什么是双亲委派机制？它有啥优势？可以打破这种机制吗？

